<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>多线程 on 傅万斌的个人网站</title>
    <link>https://fuwanbin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
    <description>Recent content in 多线程 on 傅万斌的个人网站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>&amp;copy; 2021 &lt;a href=&#34;https://fuwanbin.github.io/&#34;&gt;Wanbin Fu&lt;/a&gt;
</copyright>
    <lastBuildDate>Tue, 11 Jan 2022 00:03:09 +0800</lastBuildDate><atom:link href="https://fuwanbin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43;11并发与多线程(三)——多个线程间的数据保护|mutex</title>
      <link>https://fuwanbin.github.io/posts/multithreading_concurrent_3/</link>
      <pubDate>Tue, 11 Jan 2022 00:03:09 +0800</pubDate>
      
      <guid>https://fuwanbin.github.io/posts/multithreading_concurrent_3/</guid>
      <description>一、没有任何保护措施的代码 class A { public: // 把收到的消息push进消息队列 void inQ() { for (int i = 0; i &amp;lt; 100000; i++) { cout &amp;lt;&amp;lt; &amp;quot;inQ执行，插入&amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; q.push_back(i); // 假设i是我们收到的消息 } } // 把消息从消息队列取出 void outQ() { for (int i = 0; i &amp;lt; 100000; i++) { if (!</description>
    </item>
    
    <item>
      <title>对象创建的线程安全</title>
      <link>https://fuwanbin.github.io/posts/createobjthread/</link>
      <pubDate>Mon, 10 Jan 2022 23:00:30 +0800</pubDate>
      
      <guid>https://fuwanbin.github.io/posts/createobjthread/</guid>
      <description>参考资料 陈硕. Linux多线程服务端编程 使用muduo C++网络库[M]. 1. 电子工业出版社, 2013-1-15.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11并发与多线程(二)——子线程传参</title>
      <link>https://fuwanbin.github.io/posts/multithreading_concurrent_2/</link>
      <pubDate>Sun, 09 Jan 2022 21:18:54 +0800</pubDate>
      
      <guid>https://fuwanbin.github.io/posts/multithreading_concurrent_2/</guid>
      <description>一、在创建线程时传递参数 代码演示  在初始化子线程时，第一个参数为 可调用对象，之后依次填入函数需要的参数。
class A { public: void operator()(int x) { fun(x); } }; void fun(int x) { cout &amp;lt;&amp;lt; &amp;quot;线程开始执行\n&amp;quot;; cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;quot;线程执行完毕\n&amp;quot;; } int main(void) { int x = 5; //函数 thread myt1(fun, x); myt1.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11并发与多线程(一)——创建一个子线程</title>
      <link>https://fuwanbin.github.io/posts/multithreading_concurrent_1/</link>
      <pubDate>Sun, 09 Jan 2022 16:40:28 +0800</pubDate>
      
      <guid>https://fuwanbin.github.io/posts/multithreading_concurrent_1/</guid>
      <description>看这篇文章默认你已经学会多线程，并发等相关基础概念。
一、引言  在之前，Windows和Linux下创建线程的函数是不同的，不能跨平台。从C++11新标准开始，C++语言本身增加对多线程的支持，意味着可移植性（跨平台），大大减少开发人员的工作量。
 为了引入C++11的多线程函数库，我们要包含一个头文件：thread。
二、创建一个子线程 程序演示  以下程序包含两个线程，对应两条程序执行线路。主线程执行main()函数，在main()函数中会创建一个子线程，这个子线程会执行fun()。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;thread&amp;gt; using namespace std; // 创建一个函数作为线程的入口。 void fun() { cout &amp;lt;&amp;lt; &amp;quot;线程开始执行\n&amp;quot;; cout &amp;lt;&amp;lt; &amp;quot;线程执行完毕\n&amp;quot;; } int main() { // 创建一个thread实例,用我们写的函数fun初始化，创建完毕该线程会自动执行我们给定的函数。 // 可用其他的 可调用对象 初始化，下面会讲 thread myt(fun); cout &amp;lt;&amp;lt; myt.</description>
    </item>
    
  </channel>
</rss>
